#   Generate Jenkinsfile for project, to test automatically on Jenkins v2.x+
#
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
#
#   Copyright (c) the Contributors as noted in the AUTHORS file.
#   This file is part of zproject.
#
#   This Source Code Form is subject to the terms of the Mozilla Public
#   License, v. 2.0. If a copy of the MPL was not distributed with this
#   file, You can obtain one at http://mozilla.org/MPL/2.0/.

register_target ("jenkins", "pipeline CI script for jenkins")

.function isSingle_jenkins_agent (project, global_agent)
.# See details below in jenkins_agent()
.   if ( ( ( ( !(defined (project.jenkins_agent_single)) | (project.jenkins_agent_single ?= 0) ) & (my.global_agent ?= 0) ) ) | ( (my.global_agent ?= 1) & ( project.jenkins_agent_single ?= 1 ) ) )
.       return 1
.   endif
.   return 0
.endfunction

.function jenkins_agent (project, global_agent)
.# An "agent_single" setup defines one of the choices from project.xml
.# in the head of Jenkinsfile, and no more agents in individual steps.
.# The opposite setup (default) uses "agent none" at the top and sets
.# the agents in each step of the build and test, to spread the load.
.# The "global_agent" option is "1" in header and "0" in steps, to
.# specify whether we want anything to be printed at that position.
.   if ( isSingle_jenkins_agent(project, my.global_agent) )
.# Project can be built and tested in a single agent, or can spread
.# the load across executors or even different agents
.     if defined (project.jenkins_agent_docker)
>                   agent \{ docker \{ image '$(project.jenkins_agent_docker:)' } }
.     elsif defined (project.jenkins_docker)
.# Legacy naming for the variable
>                    agent \{ docker \{ image '$(project.jenkins_docker:)' } }
.     elsif defined (project.jenkins_agent_label)
>                    agent \{ label "$(project.jenkins_agent_label:)" }
.     else
>                    agent any
.     endif
.     return 1
.   else
.     if ( (my.global_agent ?= 1) | (project.jenkins_agent_single ?= 0) )
.# This option only happens in the header of the file, not in steps
>    agent none
.     return 1
.     endif
.   endif
.   return 0
.endfunction

.macro target_jenkins
. if defined (project.jenkins_file)
.   jenkinsfile = project.jenkins_file
. else
.   jenkinsfile = 'Jenkinsfile'
. endif
. if file.exists (jenkinsfile)
.    echo "NOT regenerating an existing Jenkins file '$(jenkinsfile:)'; you might want to move yours out of the way and re-generate the project again to get updated settings"
. else
.    output jenkinsfile
/*
    $(project.name) - $(project.description?'':)

.   for project.license
    $(string.trim (license.):block                                         )
.   endfor
*/

pipeline {
.       jenkins_agent (project, 1)
    triggers {
        pollSCM 'H/5 * * * *'
    }
.# TODO: augment the envvars to benefit from CCACHE (PATH for the binaries, CCACHE_BASEDIR to cache the project objects relative to its random workspace name)
.# TODO: Add a --enable-address-sanitizer=yes matrix
    stages {
        stage ('prepare') {
.       jenkins_agent (project, 0)
            steps {
                sh './autogen.sh'
                stash (name: 'prepped', includes: '**/*')
            }
        }
        stage ('compile') {
            parallel {
                stage ('build with DRAFT') {
.       jenkins_agent (project, 0)
                    steps {
.       if !(isSingle_jenkins_agent (project, 0))
                      dir("tmp/build-withDRAFT") {
                        deleteDir()
.       endif
                        unstash 'prepped'
                        sh './configure --enable-drafts=yes'
                        sh 'make -k -j4 || make'
                        sh 'echo "Are GitIgnores good after make with drafts? (should have no output below)"; git status -s || true'
                        stash (name: 'built-draft', includes: '**/*')
.       if !(isSingle_jenkins_agent (project, 0))
                      }
.       endif
                    }
                }
                stage ('build without DRAFT') {
.       jenkins_agent (project, 0)
                    steps {
.       if !(isSingle_jenkins_agent (project, 0))
                      dir("tmp/build-withoutDRAFT") {
                        deleteDir()
.       endif
                        unstash 'prepped'
                        sh './configure --enable-drafts=no'
                        sh 'make -k -j4 || make'
                        sh 'echo "Are GitIgnores good after make without drafts? (should have no output below)"; git status -s || true'
                        stash (name: 'built-nondraft', includes: '**/*')
.       if !(isSingle_jenkins_agent (project, 0))
                      }
.       endif
                    }
                }
                stage ('build with DOCS') {
.       jenkins_agent (project, 0)
                    steps {
.       if !(isSingle_jenkins_agent (project, 0))
                      dir("tmp/build-DOCS") {
                        deleteDir()
.       endif
                        unstash 'prepped'
                        sh './configure --enable-drafts=yes --with-docs=yes'
                        sh 'make -k -j4 || make'
                        sh 'echo "Are GitIgnores good after make with docs? (should have no output below)"; git status -s || true'
.       if !(isSingle_jenkins_agent (project, 0))
                      }
.       endif
                    }
                }
            }
        }
        stage ('check') {
            parallel {
                stage ('check with DRAFT') {
.       jenkins_agent (project, 0)
                    steps {
.       if !(isSingle_jenkins_agent (project, 0))
                      dir("tmp/test-check-withDRAFT") {
                        deleteDir()
.       endif
                        unstash 'built-draft'
                        timeout (time: 5, unit: 'MINUTES') {
                            sh 'make check'
                        }
                        sh 'echo "Are GitIgnores good after make check with drafts? (should have no output below)"; git status -s || true'
.       if !(isSingle_jenkins_agent (project, 0))
                      }
.       endif
                    }
                }
                stage ('check without DRAFT') {
.       jenkins_agent (project, 0)
                    steps {
.       if !(isSingle_jenkins_agent (project, 0))
                      dir("tmp/test-check-withoutDRAFT") {
                        deleteDir()
.       endif
                        unstash 'built-nondraft'
                        timeout (time: 5, unit: 'MINUTES') {
                            sh 'make check'
                        }
                        sh 'echo "Are GitIgnores good after make check without drafts? (should have no output below)"; git status -s || true'
.       if !(isSingle_jenkins_agent (project, 0))
                      }
.       endif
                    }
                }
                stage ('memcheck with DRAFT') {
.       jenkins_agent (project, 0)
                    steps {
.       if !(isSingle_jenkins_agent (project, 0))
                      dir("tmp/test-memcheck-withDRAFT") {
                        deleteDir()
.       endif
                        unstash 'built-draft'
                        timeout (time: 5, unit: 'MINUTES') {
                            sh 'make memcheck && exit 0 ; echo "Re-running failed ($?) memcheck with greater verbosity" >&2 ; make VERBOSE=1 memcheck-verbose'
                        }
                        sh 'echo "Are GitIgnores good after make memcheck with drafts? (should have no output below)"; git status -s || true'
.       if !(isSingle_jenkins_agent (project, 0))
                      }
.       endif
                    }
                }
                stage ('memcheck without DRAFT') {
.       jenkins_agent (project, 0)
                    steps {
.       if !(isSingle_jenkins_agent (project, 0))
                      dir("tmp/test-memcheck-withoutDRAFT") {
                        deleteDir()
.       endif
                        unstash 'built-nondraft'
                        timeout (time: 5, unit: 'MINUTES') {
                            sh 'make memcheck && exit 0 ; echo "Re-running failed ($?) memcheck with greater verbosity" >&2 ; make VERBOSE=1 memcheck-verbose'
                        }
                        sh 'echo "Are GitIgnores good after make memcheck without drafts? (should have no output below)"; git status -s || true'
.       if !(isSingle_jenkins_agent (project, 0))
                      }
.       endif
                    }
                }
.  if project.jenkins_distcheck ?= 0
.  else
                stage ('distcheck with DRAFT') {
.       jenkins_agent (project, 0)
                    steps {
.       if !(isSingle_jenkins_agent (project, 0))
                      dir("tmp/test-distcheck-withDRAFT") {
                        deleteDir()
.       endif
                        unstash 'built-draft'
                        timeout (time: 10, unit: 'MINUTES') {
                            sh 'make distcheck'
                        }
                        sh 'echo "Are GitIgnores good after make distcheck with drafts? (should have no output below)"; git status -s || true'
.       if !(isSingle_jenkins_agent (project, 0))
                      }
.       endif
                    }
                }
                stage ('distcheck without DRAFT') {
.       jenkins_agent (project, 0)
                    steps {
.       if !(isSingle_jenkins_agent (project, 0))
                      dir("tmp/test-distcheck-withoutDRAFT") {
                        deleteDir()
.       endif
                        unstash 'built-nondraft'
                        timeout (time: 10, unit: 'MINUTES') {
                            sh 'make distcheck'
                        }
                        sh 'echo "Are GitIgnores good after make distcheck without drafts? (should have no output below)"; git status -s || true'
.       if !(isSingle_jenkins_agent (project, 0))
                      }
.       endif
                    }
                }
.  endif
            }
        }
    }
    post {
        success {
            script {
                if (currentBuild.getPreviousBuild()?.result != 'SUCCESS') {
                    // Uncomment desired notification

                    //slackSend (color: "#008800", message: "Build ${env.JOB_NAME} is back to normal.")
                    //emailext (to: "qa@example.com", subject: "Build ${env.JOB_NAME} is back to normal.", body: "Build ${env.JOB_NAME} is back to normal.")
                }
            }
        }
        failure {
            // Uncomment desired notification
            // Section must not be empty, you can delete the sleep once you set notification
            sleep 1
            //slackSend (color: "#AA0000", message: "Build ${env.BUILD_NUMBER} of ${env.JOB_NAME} ${currentBuild.result} (<${env.BUILD_URL}|Open>)")
            //emailext (to: "qa@example.com", subject: "Build ${env.JOB_NAME} failed!", body: "Build ${env.BUILD_NUMBER} of ${env.JOB_NAME} ${currentBuild.result}\\nSee ${env.BUILD_URL}")
        }
    }
}
. endif
.endmacro
