#   Generate minimal JNI language bindings.
#
#   These are not meant to be idiomatic, but to provide a minimal platform
#   of JNI function bindings on which to base idiomatic Java classes.
#
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/zeromq/gsl for details.
#
#   Copyright (c) the Contributors as noted in the AUTHORS file.
#   This file is part of zproject.
#
#   This Source Code Form is subject to the terms of the Mozilla Public
#   License, v. 2.0. If a copy of the MPL was not distributed with this
#   file, You can obtain one at http://mozilla.org/MPL/2.0/.

register_target ("java", "Java JNI binding")

#   Target provides name space isolation for its functions
function target_java

gsl from "zproject_java_lib.gsl"

.macro generate_wrapper
.output "$(topdir)/$(project.prefix:c)-jni/CMakeLists.txt"
$(project.GENERATED_WARNING_HEADER:)
cmake_minimum_required (VERSION 2.8)

project ($(project.prefix)jni CXX)
enable_language (C)

# Search for Find*.cmake files in the following locations
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}")
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/../../..")

########################################################################
# JNI dependency
########################################################################
find_package (JNI REQUIRED)
include_directories (${JAVA_INCLUDE_PATH} ${JAVA_INCLUDE_PATH2} src/native/include)
.for use where use.optional = 0

########################################################################
# $(USE.PROJECT) dependency
########################################################################
find_package($(use.project) REQUIRED)
IF ($(USE.PROJECT)_FOUND)
    include_directories(${$(USE.PROJECT)_INCLUDE_DIRS})
    list(APPEND MORE_LIBRARIES ${$(USE.PROJECT)_LIBRARIES})
ELSE ($(USE.PROJECT)_FOUND)
    message( FATAL_ERROR "$(use.project) not found." )
ENDIF ($(USE.PROJECT)_FOUND)
.endfor

########################################################################
# $(PROJECT.PREFIX) dependency
########################################################################
find_package($(project.prefix) REQUIRED)
IF ($(PROJECT.PREFIX)_FOUND)
    include_directories(${$(PROJECT.PREFIX)_INCLUDE_DIRS})
    list(APPEND MORE_LIBRARIES ${$(PROJECT.PREFIX)_LIBRARIES})
ELSE ($(PROJECT.PREFIX)_FOUND)
    message( FATAL_ERROR "$(project.prefix) not found." )
ENDIF ($(PROJECT.PREFIX)_FOUND)

set ($(project.prefix)jni_sources
.for project.class where class.okay
    src/main/c/$(namespace:c)_$(class.name:pascal).c
.endfor
)

add_library ($(project.prefix)jni SHARED ${$(project.prefix)jni_sources})
add_definitions (-D$(PROJECT.PREFIX)_BUILD_DRAFT_API)

set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -pedantic -O2")
set (CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build)
set (CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build)
set (CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build)

target_link_libraries ($(project.prefix)jni ${MORE_LIBRARIES})
.
.output "$(topdir)/$(project.prefix:c)-jni/Find$(project.name:c).cmake"
$(project.GENERATED_WARNING_HEADER:)

if (NOT MSVC)
    include(FindPkgConfig)
    pkg_check_modules(PC_$(PROJECT.NAME) "$(project.libname)")
    if (NOT PC_$(PROJECT.NAME)_FOUND)
        pkg_check_modules(PC_$(PROJECT.NAME) "$(project.libname)")
    endif (NOT PC_$(PROJECT.NAME)_FOUND)
    if (PC_$(PROJECT.NAME)_FOUND)
        # some libraries install the headers is a subdirectory of the include dir
        # returned by pkg-config, so use a wildcard match to improve chances of finding
        # headers and SOs.
        set(PC_$(PROJECT.NAME)_INCLUDE_HINTS ${PC_$(PROJECT.NAME)_INCLUDE_DIRS} ${PC_$(PROJECT.NAME)_INCLUDE_DIRS}/*)
        set(PC_$(PROJECT.NAME)_LIBRARY_HINTS ${PC_$(PROJECT.NAME)_LIBRARY_DIRS} ${PC_$(PROJECT.NAME)_LIBRARY_DIRS}/*)
    endif(PC_$(PROJECT.NAME)_FOUND)
endif (NOT MSVC)

find_path (
    $(PROJECT.NAME)_INCLUDE_DIRS
    NAMES $(project.header)
    HINTS ${PC_$(PROJECT.NAME)_INCLUDE_HINTS}
)

find_library (
    $(PROJECT.NAME)_LIBRARIES
    NAMES $(project.prefix)
    HINTS ${PC_$(PROJECT.NAME)_LIBRARY_HINTS}
)

include(FindPackageHandleStandardArgs)

find_package_handle_standard_args(
    $(PROJECT.NAME)
    REQUIRED_VARS $(PROJECT.NAME)_LIBRARIES $(PROJECT.NAME)_INCLUDE_DIRS
)
mark_as_advanced(
    $(PROJECT.NAME)_FOUND
    $(PROJECT.NAME)_LIBRARIES $(PROJECT.NAME)_INCLUDE_DIRS
)

$(project.GENERATED_WARNING_HEADER:)
.
.output "$(topdir)/build.gradle"
/*
$(project.GENERATED_WARNING_HEADER:)
*/

plugins {
    id 'java'
    id 'maven-publish'
    id 'com.jfrog.artifactory' version '4.9.9'
    id 'com.jfrog.bintray' version '1.8.4'
    id 'com.google.osdetector' version '1.6.2'
}

wrapper.gradleVersion = '6.1.1'

subprojects {
    apply plugin: 'java'
    apply plugin: 'maven-publish'
    apply plugin: 'com.jfrog.bintray'
    apply plugin: 'com.jfrog.artifactory'
    apply plugin: 'com.google.osdetector'

    sourceCompatibility = 1.8
    targetCompatibility = 1.8

    repositories {
        mavenLocal()
        mavenCentral()
        jcenter()
    }

    group = '$(project.namespace)'

    if (project.hasProperty('isRelease')) {
        version = '$(->version.major).$(->version.minor).$(->version.patch)'
    } else {
        version = '$(->version.major).$(->version.minor).$(->version.patch)-SNAPSHOT'
    }
}

artifactory {
    contextUrl = "https://oss.jfrog.org/artifactory"   //The base Artifactory URL if not overridden by the publisher/resolver
    publish {
        repository {
            repoKey = 'oss-snapshot-local'
            username = System.getenv('ARTIFACTORY_USERNAME')
            password = System.getenv('ARTIFACTORY_PASSWORD')
            maven = true
        }
    }
}

bintrayPublish.enabled = false
.
.output "$(topdir)/$(project.prefix:c)-jni/build.gradle"
/*
$(project.GENERATED_WARNING_HEADER:)
*/

ext {
    jni_dependencies_version = hasProperty('isRelease') ? 'latest.release' : 'latest.integration'
}

dependencies {
.   for project.use
.       if count (project->dependencies.class, class.project = use.project) > 0
    compile "org.zeromq.$(use.project):$(use.project)-jni:$jni_dependencies_version"
.       endif
.   endfor
    compile 'org.scijava:native-lib-loader:2.3.4'
    testCompile 'junit:junit:4.12'
    testCompile 'org.hamcrest:hamcrest-all:1.3'
}

//  ------------------------------------------------------------------
//  Build section

task generateJniHeaders(type: Exec, dependsOn: 'classes') {
    def classpath = sourceSets.main.output.classesDirs
    def appclasspath = configurations.runtime.files*.getAbsolutePath().join(File.pathSeparator)
    def nativeIncludes = 'src/native/include'
    def jniClasses = [
.   for project.class where class.okay
            'src/main/java/$(name_path)/$(name:pascal).java'$(last ()?? ''? ',')
.   endfor
    ]
    def utilityClasses = [
            'src/main/java/org/zeromq/tools/ZmqNativeLoader.java'
    ]
    commandLine("javac", "-h", "$nativeIncludes", "-classpath", "$classpath${File.pathSeparator}$appclasspath", *jniClasses, *utilityClasses)
}

tasks.withType(Test) {
    def defaultJavaLibraryPath = System.getProperty("java.library.path")
    if (osdetector.os == 'windows') {
        systemProperty "java.library.path", "${projectDir}/build/Release${File.pathSeparator}${defaultJavaLibraryPath}"
    } else {
        systemProperty "java.library.path", "${projectDir}${File.pathSeparator}${defaultJavaLibraryPath}${File.pathSeparator}/usr/local/lib${File.pathSeparator}/tmp/lib"
    }
}

task initCMake(type: Exec, dependsOn: 'generateJniHeaders') {
    if (osdetector.os == 'windows') {
        def includePath = "${rootDir}/../../include"
.   for project.use
        includePath += "${File.pathSeparator}${rootDir}/../../../$(use.project)/include"
.   endfor
        workingDir  'build'
        commandLine 'cmake',
                    '-G', vsGenerator,
                    '-D', "CMAKE_INCLUDE_PATH=\\"${includePath}\\"",
                    '..'
    } else {
        commandLine 'cmake', '.'
    }
}

task buildNative(type: Exec, dependsOn: 'initCMake') {
    if (osdetector.os == 'windows') {
        commandLine 'cmake',
                    '--build',  'build',
                    '--config', 'Release',
                    '--target', '$(project.prefix)jni',
                    '--', '-verbosity:Minimal',  '-maxcpucount'
    } else {
        commandLine 'make'
    }
}

jar.dependsOn buildNative
test.dependsOn buildNative

//  ------------------------------------------------------------------
//  Install and Publish section

task sourcesJar(type: Jar, dependsOn: 'classes') {
    classifier = 'sources'
    from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: 'javadoc') {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            artifact sourcesJar
            artifact javadocJar
            artifactId = '$(project.name:c)-jni'
            pom {
                name = '$(project.name:c)-jni'
                description = '$(project.description:no)'
                packaging = 'jar'
                url = '$(project.url)'
                licenses {
                    license {
                        name = 'Mozilla Public License Version 2.0'
                        url = 'https://www.mozilla.org/en-US/MPL/2.0/'
                    }
                }
                scm {
                    connection = '$(project.url).git'
                    developerConnection = '$(project.url).git'
                    url = '$(project.url)'
                }
            }
        }
    }
}

artifactoryPublish {
    publications ('mavenJava')
}


bintray {
    user = System.getenv('BINTRAY_USER')
    key = System.getenv('BINTRAY_KEY')
    publications = ['mavenJava']
    publish = true
    override = true
    pkg {
        repo = 'maven'
        name = '$(project.name:c)-jni'
        desc = '$(project.description:no)'
        userOrg = System.getenv('BINTRAY_USER_ORG')
        licenses = ['MPL-2.0']
        websiteUrl = '$(project.url)'
        issueTrackerUrl = '$(project.url)/issues'
        vcsUrl = '$(project.url).git'
        githubRepo = System.getenv('BINTRAY_USER_ORG') + '/$(project.name:c)'
        version {
            name = project.version
            vcsTag= project.version
        }
    }
}

//  ------------------------------------------------------------------
//  Cleanup section

clean.doFirst {
    delete 'CMakeFiles', 'msvc'
    delete fileTree(projectDir) {
        include '*.so'
        include '*.dylib'
        include 'cmake_install.cmake'
        include 'Makefile'
        include 'CMakeCache.txt'
    }
}
.
.directory.create ("$(topdir)/$(project.prefix:c)-jni-all")
.output "$(topdir)/$(project.prefix:c)-jni-all/build.gradle"
/*
$(project.GENERATED_WARNING_HEADER:)
*/

dependencies {
    compile project(':$(project.prefix:c)-jni')
    runtimeOnly "$(project.namespace):$(project.prefix:c)-jni-linux-x86_64:${project.version}"
    runtimeOnly "$(project.namespace):$(project.prefix:c)-jni-osx-x86_64:${project.version}"
    runtimeOnly "$(project.namespace):$(project.prefix:c)-jni-windows-x86_64:${project.version}"
.   for project.use
.       if count (project->dependencies.class, class.project = use.project) > 0
    compile 'org.zeromq.$(use.project):$(use.project)-jni:latest.release'
    runtimeOnly 'org.zeromq.$(use.project):$(use.project)-jni-all:latest.release'
.       endif
.   endfor
}

//  ------------------------------------------------------------------
//  Install and Publish section

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            artifactId = '$(project.name:c)-jni-all'
            pom {
                name = '$(project.name:c)-jni-all'
                description = '$(project.description:no)'
                packaging = 'jar'
                url = '$(project.url)'
                licenses {
                    license {
                        name = 'Mozilla Public License Version 2.0'
                        url = 'https://www.mozilla.org/en-US/MPL/2.0/'
                    }
                }
                scm {
                    connection = '$(project.url).git'
                    developerConnection = '$(project.url).git'
                    url = '$(project.url)'
                }
            }
        }
    }
}

artifactoryPublish {
    publications ('mavenJava')
}


bintray {
    user = System.getenv('BINTRAY_USER')
    key = System.getenv('BINTRAY_KEY')
    publications = ['mavenJava']
    publish = true
    override = true
    pkg {
        repo = 'maven'
        name = '$(project.name:c)-jni-all'
        desc = '$(project.description:no)'
        userOrg = System.getenv('BINTRAY_USER_ORG')
        licenses = ['MPL-2.0']
        websiteUrl = '$(project.url)'
        issueTrackerUrl = '$(project.url)/issues'
        vcsUrl = '$(project.url).git'
        githubRepo = System.getenv('BINTRAY_USER_ORG') + '/$(project.name:c)'
        version {
            name = project.version
            vcsTag= project.version
        }
    }
}
.
.directory.create ("$(topdir)/$(project.prefix:c)-jni-native")
.output "$(topdir)/$(project.prefix:c)-jni-native/build.gradle"
/*
$(project.GENERATED_WARNING_HEADER:)
*/

dependencies {
    compile project(':$(project.prefix:c)-jni')
.   for project.use
.       if count (project->dependencies.class, class.project = use.project) > 0
    runtimeOnly "org.zeromq.$(use.project):$(use.project)-jni-${osdetector.classifier}:latest.release"
.       endif
.   endfor
}

//  ------------------------------------------------------------------
//  Build section

task copyLibs(type: Copy) {
    def libraryPaths = System.getProperty('java.library.path').split(File.pathSeparator).toList()
    libraryPaths.add('/usr/local/lib')
    libraryPaths.add("${rootDir}/$(project.prefix:c)-jni")
    libraryPaths.add("${rootDir}/$(project.prefix:c)-jni/build/Release")

    libraryPaths.each { path ->
        from path
            include '$(project.libname)jni.so'
            include '$(project.libname)jni.dylib'
            include '*$(project.prefix:c)jni*.dll'
            include '$(project.libname).so'
            include '$(project.libname).dylib'
            include '*$(project.prefix:c)*.dll'
.   for project.use
            include '$(use.libname).so'
            include '$(use.libname).dylib'
            include '*$(use.prefix:c)*.dll'
.   endfor
        into 'build/natives'
    }
}

jar.baseName = "$(project.prefix:c)-jni-${osdetector.classifier}"
jar.dependsOn copyLibs

jar {
    def arch = osdetector.arch.contains('64') ? '64' : '32'
    from 'build/natives'
        include '*'
    into "natives/${osdetector.os}_${arch}"
}

//  ------------------------------------------------------------------
//  Install and Publish section

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            artifactId = "$(project.name:c)-jni-${osdetector.classifier}"
            pom {
                name = "$(project.name:c)-jni-${osdetector.classifier}"
                description = '$(project.description:no)'
                packaging = 'jar'
                url = '$(project.url)'
                licenses {
                    license {
                        name = 'Mozilla Public License Version 2.0'
                        url = 'https://www.mozilla.org/en-US/MPL/2.0/'
                    }
                }
                scm {
                    connection = '$(project.url).git'
                    developerConnection = '$(project.url).git'
                    url = '$(project.url)'
                }
            }
        }
    }
}

artifactoryPublish {
    publications ('mavenJava')
}

bintray {
    user = System.getenv('BINTRAY_USER')
    key = System.getenv('BINTRAY_KEY')
    publications = ['mavenJava']
    publish = true
    override = true
    pkg {
        repo = 'maven'
        name = "$(project.name:c)-jni-${osdetector.classifier}"
        desc = '$(project.description:no)'
        userOrg = System.getenv('BINTRAY_USER_ORG')
        licenses = ['MPL-2.0']
        websiteUrl = '$(project.url)'
        issueTrackerUrl = '$(project.url)/issues'
        vcsUrl = '$(project.url).git'
        githubRepo = System.getenv('BINTRAY_USER_ORG') + '/$(project.name:c)'
        version {
            name = project.version
            vcsTag= project.version
        }
    }
}

//  ------------------------------------------------------------------
//  Cleanup section

clean.doFirst {
    delete fileTree(projectDir) {
        include '*.so'
        include '*.dylib'
    }
}
.
.output "$(topdir)/README.md"
# $(project.prefix)-jni

[ ![Download](https://api.bintray.com/packages/zeromq/maven/$(project.prefix)-jni/images/download.svg) ](https://bintray.com/zeromq/maven/$(project.prefix)-jni/_latestVersion)

JNI Binding for $(project.name:)

## Building the JNI Layer for Linux

Ensure you have gradle and cmake installed, then run:

    gradle build jar
    gradle test

If you don't like to install gradle beforehand just use the gradle wrapper.

    ./gradlew build jar
    ./gradlew test

This calls javah to build the headers in src/native/include, and then compiles the C and Java pieces to create a jar file a sharable library (.so).

## Building the JNI Layer for Android

Please read the prerequisites section of the [README](../../builds/android/README.md) in the android build directory.

You only need to set the environment variables.

Then in the jni's android directory ($(project.prefix)-jni/android), run:

    ./build.sh [ arm | arm64 | x86 | x86_64 ]

This does the following:

* It compiles the $(project.name:) C sources for Android, into a native library $(project.libname).so in /tmp/android_build/<architecture>/lib
* It compiles the JNI Java classes into a jar file $(project.prefix)-jni-$(->version.major).$(->version.minor).$(->version.patch).jar in bindings/jni/$(project.prefix)-jni/build/libs
* It compiles the JNI C sources for Android, into a native library $(project.libname)jni.so.
.for project.use
.   if count (project->dependencies.class, class.project = use.project) > 0
* It takes $(use.project)-jni-*.jar, which must already be built in ../$(use.project)/bindings/jni/$(use.prefix)-jni/build/libs/
.   endif
.endfor
* It combines all these into jar file for the built architecture, which you can use in your Android projects.
* It merges the jar files built for the different architectures into one jar file.

## Building the JNI Layer for Windows

Prerequisites:
* MS Visual Studio or MS Visual Studio Tools 2010 or later are installed
* Java JDK 8 or later is installed

Environment Variables:
* Add MSBuild.exe to the PATH, e.g. C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\MSBuild\\Current\\Bin
* Set JAVA_HOME to the installation location, e.g. C:\\Program Files\\Java\\jdk1.8.0_66.

1. Check out all dependent projects from github, at the same level as this project. E.g.: libzmq, czmq.
2. Follow the dependent projects instuctions to build thier '.dll' and '.lib' file.
3. Copy a dependent '.dll' and '.lib' files to a folder
4. Add this library folder to the path, e.g.:

	PATH %PATH%;C:\\projects\\libs

Now run:

	gradlew build jar "-PvsGenerator=Visual Studio 16 2019"
	gradlew test "-PvsGenerator=Visual Studio 16 2019"

Change the vsGenerator parameter to the version of MS Visual Studio you have installed.

## Installing the JNI Layer

If you like to use this JNI Layer in another project you'll need to distribute it
to a location where the other project can locate it. The easiest way to do this
is by leveraging maven and install to the local maven repository located at
$HOME/.m2. Therefore simply run:

    ./gradlew publishToMavenLocal

## Using the JNI API

- to be written.

## License

$(project->license.:)

## Information for maintainers

### Building the gradle wrapper

The gradle wrapper is a tool that allows to use gradle on multiple platforms
without installing it beforehand. Make sure you have installed a version of
gradle that is at least the version the wrapper should have (local version >=  wrapper version).
Then just run

    gradle wrapper

Now commit all generated files to the project. Yes the jar file as well! Users
will now be able to call the gradle wrapper (gradlew) which will install gradle
for them.

### Travis build

Travis can build and check this jni layer there add the following line to your
travis environment matrix

    - BUILD_TYPE=bindings BINDING=jni

### Travis deploy to bintray

When tagging a release travis can automatically deploy this jni layer to bintray.
Therefore you'll need to supply travis with three environment variables:

* BINTRAY_USER - your personal user name
* BINTRAY_KEY - your personal api key
* BINTRAY_USER_ORG - the organisation you like to publish to

You may extent .travis.yml as follows

    - BUILD_TYPE=bindings BINDING=jni BINTRAY_USER=<user> BINTRAY_KEY=<key> BINTRAY_USER_ORG=<org>

But I recommend to encrypt your bintray api key. This can be done with the
travis commandline client

    travis encrypt BINTRAY_KEY=123...

Please be aware that secure environmental variables can only be added as global.

    global:
       - secure: "ZMvDhR..."
    matrix:
       - BUILD_TYPE=bindings BINDING=jni BINTRAY_USER=<user> BINTRAY_USER_ORG=<org>

.
.output "$(topdir)/settings.gradle"
rootProject.name = '$(project.prefix)-jni'
include '$(project.prefix)-jni'
include '$(project.prefix)-jni-native'
include '$(project.prefix)-jni-all'
.
.output "$(topdir)/.gitignore"
CMakeCache.txt
CMakeFiles/
cmake_install.cmake
\.gradle
build/
src/native
gradle-app.setting
$(project.libname)jni.so
*.class
.
.directory.create ("$(topdir)/$(project.prefix:c)-jni/android")
.terminator="\n"
.output "$(topdir)/$(project.prefix:c)-jni/android/build.sh"
#!/bin/bash
$(project.GENERATED_WARNING_HEADER:)
#   Build JNI interface for Android
#
#   Requires these environment variables be set, e.g.:
#
#     ANDROID_NDK_ROOT=$HOME/android-ndk-r20
#
#   Exit if any step fails
set -e

# Set this to enable verbose profiling
[ -n "${CI_TIME-}" ] || CI_TIME=""
case "$CI_TIME" in
    [Yy][Ee][Ss]|[Oo][Nn]|[Tt][Rr][Uu][Ee])
        CI_TIME="time -p " ;;
    [Nn][Oo]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee])
        CI_TIME="" ;;
esac

# Set this to enable verbose tracing
[ -n "${CI_TRACE-}" ] || CI_TRACE="no"
case "$CI_TRACE" in
    [Nn][Oo]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee])
        set +x ;;
    [Yy][Ee][Ss]|[Oo][Nn]|[Tt][Rr][Uu][Ee])
        set -x
        MAKE_OPTIONS=VERBOSE=1
        ;;
esac

function usage {
    echo "Usage ./build.sh [ arm | arm64 | x86 | x86_64 ]"
}

BUILD_ARCH=$1
if [ -z $BUILD_ARCH ]; then
    usage
    exit 1
fi

source ../../../../builds/android/android_build_helper.sh

export MIN_SDK_VERSION=21
export ANDROID_BUILD_DIR=/tmp/android_build

#   Build any dependent libraries
#   Use a default value assuming that dependent libraries sits alongside this one
.for project.use
.   if count (project->dependencies.class, class.project = use.project) > 0
( cd ${$(USE.PROJECT)_ROOT:-../../../../../$(use.project)}/bindings/jni/$(use.prefix)-jni/android; ./build.sh $BUILD_ARCH )
.   endif
.endfor

#   Ensure we've built dependencies for Android
echo "********  Building $(project.name:) Android native libraries"
( cd ../../../../builds/android && ./build.sh $BUILD_ARCH )

#   Ensure we've built JNI interface
echo "********  Building $(project.name:) JNI interface & classes"
( cd ../.. && ./gradlew build jar --info )

echo "********  Building $(project.name:) JNI for Android"
rm -rf build && mkdir build && cd build
# Export android build's environment variables for cmake
android_build_set_env $BUILD_ARCH
cmake -v \\
    -DANDROID_ABI=$TOOLCHAIN_ABI \\
    -DANDROID_PLATFORM=$MIN_SDK_VERSION \\
    -DANDROID_STL=c++_shared \\
    -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK_ROOT/build/cmake/android.toolchain.cmake \\
    -DCMAKE_FIND_ROOT_PATH=$ANDROID_BUILD_PREFIX \\
    ..

#   CMake wrongly searches current directory and then toolchain path instead
#   of lib path for these files, so make them available temporarily
ln -s $ANDROID_SYS_ROOT/usr/lib/crtend_so.o
ln -s $ANDROID_SYS_ROOT/usr/lib/crtbegin_so.o

make $MAKE_OPTIONS

echo "********  Building jar for $TOOLCHAIN_ABI"
#   Copy class files into org/zeromq/etc.
find ../../build/libs/ -type f -name '$(project.prefix)-jni-*.jar' ! -name '*javadoc.jar' ! -name '*sources.jar' -exec unzip -q {} +
.for project.use
.   if count (project->dependencies.class, class.project = use.project) > 0
unzip -qo "${$(USE.PROJECT)_ROOT:-../../../../../../$(use.project)}/bindings/jni/$(use.project)-jni/android/$(use.project)-android*$TOOLCHAIN_ABI*.jar"
.   endif
.endfor

#   Copy native libraries into lib/$TOOLCHAIN_ABI
mkdir -p lib/$TOOLCHAIN_ABI
cp $(project.libname)jni.so lib/$TOOLCHAIN_ABI
cp $ANDROID_BUILD_PREFIX/lib/*.so lib/$TOOLCHAIN_ABI
cp $ANDROID_NDK_ROOT/sources/cxx-stl/llvm-libc++/libs/$TOOLCHAIN_ABI/libc++_shared.so lib/$TOOLCHAIN_ABI

#   Build android jar
zip -r -m ../$(project.prefix)-android-$TOOLCHAIN_ABI-$(->version.major).$(->version.minor).$(->version.patch).jar lib/ org/ META-INF/
cd ..
rm -rf build

echo "********  Merging ABI jars"
mkdir build && cd build
#   Copy contents from all ABI jar - overwriting class files and manifest
unzip -qo '../$(project.prefix)-android-*$(->version.major).$(->version.minor).$(->version.patch).jar'
#   Build merged jar
zip -r -m ../$(project.prefix)-android-$(->version.major).$(->version.minor).$(->version.patch).jar lib/ org/ META-INF/
cd ..
rm -rf build

echo "********  Complete"
.chmod_x ("$(topdir)/$(project.prefix:c)-jni/android/build.sh")
.
.output "$(topdir)/$(project.prefix:c)-jni/android/CMakeLists.txt"
$(project.GENERATED_WARNING_HEADER:)
cmake_minimum_required (VERSION 3.6)

project ($(project.name:c)jni CXX)
enable_language (C)

# Search for Find*.cmake files in the following locations
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/..")
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/../../../..")
.for use where use.optional = 0

########################################################################
# $(USE.PROJECT) dependency
########################################################################
find_package($(use.project) REQUIRED)
IF ($(USE.PROJECT)_FOUND)
    include_directories(${$(USE.PROJECT)_INCLUDE_DIRS})
    list(APPEND MORE_LIBRARIES ${$(USE.PROJECT)_LIBRARIES})
ELSE ($(USE.PROJECT)_FOUND)
    message( FATAL_ERROR "$(use.project) not found." )
ENDIF ($(USE.PROJECT)_FOUND)
.endfor

########################################################################
# $(PROJECT.PREFIX) dependency
########################################################################
find_package($(project.prefix) REQUIRED)
IF ($(PROJECT.PREFIX)_FOUND)
    include_directories(${$(PROJECT.PREFIX)_INCLUDE_DIRS})
    list(APPEND MORE_LIBRARIES ${$(PROJECT.PREFIX)_LIBRARIES})
ELSE ($(PROJECT.PREFIX)_FOUND)
    message( FATAL_ERROR "$(project.prefix) not found." )
ENDIF ($(PROJECT.PREFIX)_FOUND)

include_directories(../src/native/include)

set ($(project.prefix)jni_sources
.for project.class where class.okay
    ../src/main/c/$(namespace:c)_$(class.name:pascal).c
.endfor
)

add_library ($(project.prefix)jni SHARED ${$(project.prefix)jni_sources})
add_definitions (-D$(PROJECT.PREFIX)_BUILD_DRAFT_API)

set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -pedantic -O2")
set (CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build)
set (CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build)
set (CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build)

target_link_libraries ($(project.prefix)jni ${MORE_LIBRARIES})
.
.# File has been removed in favor of NDKs android_toolchain.cmake. The delete
.# statement can be removed at some point in the future when users had time to
.# apply the changes.
.file.delete ("$(topdir)/$(project.prefix:c)-jni/android/android_toolchain.cmake")
.
.output "$(topdir)/ci_build.sh"
#!/usr/bin/env bash
$(project.GENERATED_WARNING_HEADER:)

# Set this to enable verbose profiling
[ -n "${CI_TIME-}" ] || CI_TIME=""
case "$CI_TIME" in
    [Yy][Ee][Ss]|[Oo][Nn]|[Tt][Rr][Uu][Ee])
        CI_TIME="time -p " ;;
    [Nn][Oo]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee])
        CI_TIME="" ;;
esac

# Set this to enable verbose tracing
[ -n "${CI_TRACE-}" ] || CI_TRACE="no"
case "$CI_TRACE" in
    [Nn][Oo]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee])
        set +x ;;
    [Yy][Ee][Ss]|[Oo][Nn]|[Tt][Rr][Uu][Ee])
        set -x ;;
esac

########################################################################
# Build and check the jni binding
########################################################################

BUILD_PREFIX=/tmp
$(PROJECT.PREFIX)_JNI_ROOT=${PWD}
$(PROJECT.PREFIX)_ROOT=${PWD}/../..

CONFIG_OPTS=()
CONFIG_OPTS+=("CFLAGS=-I${BUILD_PREFIX}/include")
CONFIG_OPTS+=("CPPFLAGS=-I${BUILD_PREFIX}/include")
CONFIG_OPTS+=("CXXFLAGS=-I${BUILD_PREFIX}/include")
CONFIG_OPTS+=("LDFLAGS=-L${BUILD_PREFIX}/lib")
CONFIG_OPTS+=("PKG_CONFIG_PATH=${BUILD_PREFIX}/lib/pkgconfig")
CONFIG_OPTS+=("--prefix=${BUILD_PREFIX}")
CONFIG_OPTS+=("--with-docs=no")
if [ -z "${CI_CONFIG_QUIET-}" ] || [ "${CI_CONFIG_QUIET-}" = yes ] || [ "${CI_CONFIG_QUIET-}" = true ]; then
    CONFIG_OPTS+=("--quiet")
fi

rm -rf /tmp/tmp-deps
mkdir -p /tmp/tmp-deps

# Clone and build dependencies
[ -z "$CI_TIME" ] || echo "`date`: Starting build of dependencies (if any)..."
.for use where defined (use.tarball)
export $(USE.PROJECT)_ROOT="/tmp/tmp-deps/$(use.project)"
wget $(use.tarball)
tar -xzf \$(basename "$(use.tarball)")
mv \$(basename "$(use.tarball)" .tar.gz) \$$(USE.PROJECT)_ROOT
cd \$$(USE.PROJECT)_ROOT
.       generate_compile_script (use, "tarball")

.endfor
.for use where defined (use.repository) & ! defined (use.tarball)
export $(USE.PROJECT)_ROOT="/tmp/tmp-deps/$(use.project)"
.   if defined (use.release)
$CI_TIME git clone --quiet --depth 1 -b $(use.release:) $(use.repository) $$(USE.PROJECT)_ROOT
.   else
$CI_TIME git clone --quiet --depth 1 $(use.repository) $$(USE.PROJECT)_ROOT
.   endif

cd \$$(USE.PROJECT)_ROOT
.   generate_compile_script (use, "git")

.       if count (project->dependencies.class, class.project = use.project) > 0
# Build jni dependency
( cd bindings/jni && TERM=dumb PKG_CONFIG_PATH=$BUILD_PREFIX/lib/pkgconfig $CI_TIME ./gradlew publishToMavenLocal )
.       endif

.endfor
cd \$$(PROJECT.PREFIX)_ROOT
[ -z "$CI_TIME" ] || echo "`date`: Starting build of currently tested project..."
.generate_compile_script (project, "git")
.if count (add_config_opts) > 0
# Custom additional options for this project
.   for add_config_opts as add_cfgopt
CONFIG_OPTS+=("$(add_cfgopt)")
.   endfor
.endif
$CI_TIME ./autogen.sh 2> /dev/null
$CI_TIME ./configure "${CONFIG_OPTS[@]}"
$CI_TIME make -j4
$CI_TIME make install
[ -z "$CI_TIME" ] || echo "`date`: Build completed without fatal errors!"

cd ${$(PROJECT.PREFIX)_JNI_ROOT}
IS_RELEASE=false
[ -z "$TRAVIS_TAG" ] || IS_RELEASE=true

TERM=dumb PKG_CONFIG_PATH=$BUILD_PREFIX/lib/pkgconfig $CI_TIME ./gradlew build jar -PisRelease=$IS_RELEASE --info
TERM=dumb PKG_CONFIG_PATH=$BUILD_PREFIX/lib/pkgconfig $CI_TIME ./gradlew bintrayUpload -PisRelease=$IS_RELEASE --info
TERM=dumb $CI_TIME ./gradlew clean

########################################################################
#  Build and check the jni android binding
########################################################################

if [ "$TRAVIS_OS_NAME" == "linux" ] && [ "$BINDING_OPTS" == "android" ]; then
    pushd ../../builds/android
        export NDK_VERSION=android-ndk-r20
        export ANDROID_NDK_ROOT="/tmp/${NDK_VERSION}"

		case \$(uname | tr '[:upper:]' '[:lower:]') in
		  linux*)
			HOST_PLATFORM=linux-x86_64
			;;
		  darwin*)
			HOST_PLATFORM=darwin-x86_64
			;;
		  *)
			echo "Unsupported platform"
			exit 1
			;;
		esac

        if [ ! -d "${ANDROID_NDK_ROOT}" ]; then
            export FILENAME=$NDK_VERSION-$HOST_PLATFORM.zip

            (cd '/tmp' \\
                && wget http://dl.google.com/android/repository/$FILENAME -O $FILENAME &> /dev/null \\
                && unzip -q $FILENAME) || exit 1
            unset FILENAME
        fi
    popd

    pushd $(project.prefix)-jni/android
        $CI_TIME ./build.sh "arm"
        $CI_TIME ./build.sh "arm64"
        $CI_TIME ./build.sh "x86"
        $CI_TIME ./build.sh "x86_64"
    popd
fi
.close
.chmod_x ("$(topdir)/ci_build.sh")
.if ! file.exists ("$(topdir)/gradle/wrapper/gradle-wrapper.jar")
.   echo "Note: Could not locate gradle wrapper for JNI Binding! See bindings/jni/README.md."
.endif
.endmacro

.macro generate_native_loader ()
.   directory.create ("$(topdir)/$(project.prefix:c)-jni/src/main/java/org/zeromq/tools")
.   output "$(topdir)/$(project.prefix:c)-jni/src/main/java/org/zeromq/tools/ZmqNativeLoader.java"
package org.zeromq.tools;

import org.scijava.nativelib.NativeLibraryUtil;
import org.scijava.nativelib.NativeLoader;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.URLDecoder;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

public class ZmqNativeLoader {

    private static final Set<String> loadedLibraries = new HashSet<>();

    private static final Set<String> potentialDlls = new HashSet<>();

    static {
        if (System.getProperty("os.name").toLowerCase().contains("windows")) {
            // Collect potential DLLs to be match when loading the libraries

            // 1. Lookup the java.library.path
            String javaLibraryPath = System.getProperty("java.library.path");
            if (javaLibraryPath != null) {
                final String[] paths = javaLibraryPath.split(File.pathSeparator);
                for (String path : paths) {
                    File folder = new File(path);
                    if (folder.exists()) {
                        for (final File fileEntry : folder.listFiles()) {
                            if (fileEntry.isFile() && fileEntry.getName().indexOf(".dll") != -1) {
                                potentialDlls.add(fileEntry.getName().substring(0, fileEntry.getName().indexOf(".")));
                            }
                        }
                    }
                }
            }

            // 2. Lookup the jar files
            try {
                String path = "natives/" + NativeLibraryUtil.getArchitecture().name().toLowerCase() + "/";
                URL url = ZmqNativeLoader.class.getClassLoader().getResource(path);
                if (url != null && url.getProtocol().equals("jar")) {
                    String jarPath = url.getPath().substring(5, url.getPath().indexOf("!")); // Strip out only the JAR file
                    JarFile jar = new JarFile(URLDecoder.decode(jarPath, "UTF-8"));
                    Enumeration<JarEntry> entries = jar.entries(); // Gives ALL entries in jar
                    while (entries.hasMoreElements()) {
                        String name = entries.nextElement().getName();
                        // Filter DLLs according to the path
                        if (name.startsWith(path) && name.indexOf(".dll") != -1) {
                            potentialDlls.add(name.substring(path.length(), name.length() - 4));
                        }
                    }
                }
            } catch (IOException e) {
                // Ignore!
            }
        }
    }

    public static void loadLibraries(Map<String, Boolean> libraries) {
        for (String libraryName : libraries.keySet()) {
            boolean libraryLoaded = false;
            if (System.getProperty("os.name").toLowerCase().contains("windows")) {
                // Windows DLL names are not as standardized as dynamic library names are under linux or osx.
                // Therefore we inspect potential DLLs to find a match.

                // Find all other libraries that contains this library's name
                Set<String> conflictingLibrariesNames = new HashSet<>();
                for (String otherLibraryName : libraries.keySet()) {
                    if (otherLibraryName.contains(libraryName) && !otherLibraryName.equals(libraryName)) {
                        conflictingLibrariesNames.add(otherLibraryName);
                    }
                }
                // Build regexes to exclude any prefixes and suffixes of libraries that contain this library's name
                String regexForbiddenPrefix = "";
                String regexForbiddenSuffix = "";
                if (conflictingLibrariesNames.size() > 0) {
                    for (String conflictingLibraryName : conflictingLibrariesNames) {
                        String prefix = conflictingLibraryName.substring(0, conflictingLibraryName.indexOf(libraryName));
                        if (!"".equals(prefix)) {
                            regexForbiddenPrefix += prefix + "|";
                        }
                    }
                    if (!"".equals(regexForbiddenPrefix)) {
                        regexForbiddenPrefix = regexForbiddenPrefix.substring(0, regexForbiddenPrefix.length() - 1);
                        regexForbiddenPrefix = "(?<!" + regexForbiddenPrefix + ")";
                    }

                    for (String conflictingLibraryName : conflictingLibrariesNames) {
                        String suffix = conflictingLibraryName.substring(conflictingLibraryName.indexOf(libraryName) + libraryName.length());
                        if (!"".equals(suffix)) {
                            regexForbiddenSuffix += suffix + "|";
                        }
                    }
                    if (!"".equals(regexForbiddenSuffix)) {
                        regexForbiddenSuffix = regexForbiddenSuffix.substring(0, regexForbiddenSuffix.length() - 1);
                        regexForbiddenSuffix = "(?!" + regexForbiddenSuffix + ")";
                    }
                }

                for (String fileName : potentialDlls) {
                    String regex = "^(?:lib)?.*" + regexForbiddenPrefix + libraryName + regexForbiddenSuffix + ".*$";
                    if (fileName.matches(regex)) {
                        loadLibrary(fileName, libraries.get(libraryName));
                        libraryLoaded = true;
                    }
                }
            }
            if (!libraryLoaded) {
                loadLibrary(libraryName, libraries.get(libraryName));
            }
        }
    }

    public static void loadLibrary(String libname, boolean optional) {
        if (!loadedLibraries.contains(libname)) {
            try {
                NativeLoader.loadLibrary(libname);
            } catch (IOException e) {
                if (optional) {
                    System.err
                        .println("[WARN] " + e.getMessage() + " from jar. Assuming it is installed on the system.");
                } else {
                    System.err.println("[FATAL] " + e.getMessage() + " from jar. Dependency is required!");
                    System.exit(-1);
                }
            }
            loadedLibraries.add(libname);
        }
    }

}
.endmacro

.macro generate_class_in_java (class)
.   directory.create ("$(topdir)/$(project.prefix:c)-jni/src/main/java/$(name_path)")
.   output "$(topdir)/$(project.prefix:c)-jni/src/main/java/$(name_path)/$(my.class.name:pascal).java"
/*
$(project.GENERATED_WARNING_HEADER:)
*/
package $(project.namespace);

import org.zeromq.tools.ZmqNativeLoader;

import java.util.LinkedHashMap;
import java.util.Map;
.   for project.use
.       if count (project->dependencies.class, class.project = use.project) > 0
import org.zeromq.$(use.project).*;
.       endif
.   endfor

public class $(my.class.name:pascal) \
.   if count (my.class.constructor)
implements AutoCloseable \
.   endif
{
    static {
        Map<String, Boolean> libraries = new LinkedHashMap<>();
.       for project.use
        libraries.put("$(use.prefix:c)", $(use.optional ?? 'true' ? 'false'));
.       endfor
        libraries.put("$(project.prefix:c)", false);
        libraries.put("$(project.prefix:c)jni", false);
        ZmqNativeLoader.loadLibraries(libraries);
    }
    public long self;
.   my.class.jni_void_new = 0
.   for constructor where okay
    /*
    $(description:no,block)
    */
    native static $(->return.jni_shim_type:) __$(name:camel) ($(jni_shim_signature_java:));
.       if index () = 1
    public $(my.class.name:pascal) ($(jni_method_signature:)) {
        /*  TODO: if __$(name:camel) fails, self is null...  */
        self = __$(name:camel) ($(jni_shim_invocation_java:));
    }
    public $(my.class.name:pascal) (long pointer) {
        self = pointer;
    }
.       else
    public $(static) $(->return.jni_java_type:) $(jni_name:) ($(jni_method_signature:)) {
        return new $(->return.type:pascal) (__$(name:camel) ($(jni_shim_invocation_java:)));
    }
.       endif
.   endfor
.   for destructor
    /*
    $(description:no,block)
    */
    native static void __$(name:camel) (long self);
    @Override
    public void close () {
        __$(name:camel) (self);
        self = 0;
    }
.   endfor
.   for method where okay
.       if singleton = 1 & !defined (method.return_self_p)
.           my.prefix = "public static"
.       else
.           my.prefix = "public"
.       endif
    /*
    $(description:no,block)
    */
    native static $(->return.jni_shim_type:) __$(name:camel) ($(jni_shim_signature_java:));
    $(my.prefix) $(->return.jni_java_type:) $(jni_name:) ($(jni_method_signature:)) {
.       if defined (method.return_self_p)
        self = __$(name:camel) ($(jni_shim_invocation_java:));
.       elsif ->return.type = "nothing"
        __$(name:camel) ($(jni_shim_invocation_java:));
.       elsif ->return.jni_is_class = 1
        return new $(->return.type:pascal) (__$(name:camel) ($(jni_shim_invocation_java:)));
.       else
        return __$(name:camel) ($(jni_shim_invocation_java:));
.       endif
    }
.   endfor
}
.endmacro

.macro generate_jni_method_c (method)
.   if defined (my.method.return_self_p) & !my.method.is_destructor
JNIEXPORT jlong JNICALL
.   else
JNIEXPORT $(->return.jni_jni_type:) JNICALL
.   endif
Java_$(namespace:c)_$(class.name:pascal)__1_1$(my.method.name:camel) (JNIEnv *env, jclass c\
.   if jni_shim_signature_c <> ""
, \
.   endif
$(jni_shim_signature_c:))
{
.   for argument
.       if type = "string" | type = "format"
    char *$(c_name)_ = (char *) (*env)->GetStringUTFChars (env, $(c_name), NULL);
.       elsif type = "buffer"
    jbyte *$(c_name)_ = (byte *) (*env)->GetByteArrayElements (env, $(c_name), 0);
.       endif
.   endfor
.#
.   if name = "new"
    //  Disable CZMQ signal handling; allow Java to deal with it
    zsys_handler_set (NULL);
.   endif
.   if ->return.type = "nothing"
    $(class.c_name)_$(c_name) ($(jni_native_invocation_c:));
.       if defined (my.method.return_self_p) & !my.method.is_destructor
.           my.return = "    return self;\n"
.       else
.           my.return = ""
.   endif
.#
.   elsif ->return.type = "buffer"
.       if regexp.match ("^\\.(.*)", ->return.size, my.size)
.           my.size = "$(class.c_name)_$(my.size) (($(class.c_name)_t *) (intptr_t) self)"
.       else
.           my.size = ->return.size
.       endif
    jbyte *$(c_name)_ = (jbyte *) $(class.c_name)_$(c_name) ($(jni_native_invocation_c:));
    jint return_size_ = (jint) $(my.size);
    jbyteArray return_data_ = (*env)->NewByteArray (env, return_size_);
    (*env)->SetByteArrayRegion (env, return_data_, 0, return_size_, (jbyte *) $(c_name)_);
.       my.return = "    return return_data_;\n"
.#
.   elsif ->return.type = "string"
    char *$(c_name)_ = (char *) $(class.c_name)_$(c_name) ($(jni_native_invocation_c:));
    jstring return_string_ = (*env)->NewStringUTF (env, $(c_name)_);
.       if ->return.fresh
    zstr_free (&$(c_name)_);
.       endif
.       my.return = "    return return_string_;\n"
.#
.   elsif ->return.jni_is_class = 1 | ->return.type = "anything" | ->return.type = "sockish"
    jlong $(c_name)_ = (jlong) (intptr_t) $(class.c_name)_$(c_name) ($(jni_native_invocation_c:));
.       my.return = "    return $(c_name)_;\n"
.   else
    $(->return.jni_jni_type:) $(c_name)_ = ($(->return.jni_jni_type:)) $(class.c_name)_$(c_name) ($(jni_native_invocation_c:));
.       if defined (my.method.return_self_p)
.           my.return = "    return self;\n"
.       else
.           my.return = "    return $(c_name)_;\n"
.       endif
.   endif
.#
.   for argument
.       if type = "string" | type = "format"
    (*env)->ReleaseStringUTFChars (env, $(c_name), $(c_name)_);
.       elsif type = "buffer"
    (*env)->ReleaseByteArrayElements (env, $(c_name), (jbyte *) $(c_name)_, 0);
.       endif
.   endfor
$(my.return)\
}

.endmacro

.macro generate_class_in_c (class)
.   directory.create ("$(topdir)/$(project.prefix:c)-jni/src/main/c/")
.   my.cname = "$(namespace:c)_$(my.class.name:pascal)"
.   output "$(topdir)/$(project.prefix:c)-jni/src/main/c/$(my.cname:).c"
/*
$(project.GENERATED_WARNING_HEADER:)
*/
#include <stdio.h>
#include <stdlib.h>
#include <jni.h>
#include "$(project.header:)"
#include "$(my.cname:).h"

.   for constructor where okay
.       generate_jni_method_c (constructor)
.   endfor
.   for destructor where okay
.       generate_jni_method_c (destructor)
.   endfor
.   for method where okay
.       generate_jni_method_c (method)
.   endfor
.endmacro

.macro generate_test_wrapper (class)
.   directory.create ("$(topdir)/$(project.prefix:c)-jni/src/test/java/$(name_path)")
.   output "$(topdir)/$(project.prefix:c)-jni/src/test/java/$(name_path)/$(my.class.name:pascal)Test.java"
/*
$(project.GENERATED_WARNING_HEADER:)
*/
package $(project.namespace);

import org.junit.Assert;
import org.junit.Test;
import org.scijava.nativelib.NativeLoader;

public class $(my.class.name:pascal)Test {

    @Test
    public void test () {
        $(my.class.name:pascal).test (false);
    }

}
.endmacro

.macro generate_compile_script (use, target)
.   if my.target = "git"
git --no-pager log --oneline -n1
if [ -e autogen.sh ]; then
    $CI_TIME ./autogen.sh 2> /dev/null
fi
if [ -e buildconf ]; then
    $CI_TIME ./buildconf 2> /dev/null
fi
if [ ! -e autogen.sh ] && [ ! -e buildconf ] && [ ! -e ./configure ] && [ -s ./configure.ac ]; then
    $CI_TIME libtoolize --copy --force && \\
    $CI_TIME aclocal -I . && \\
    $CI_TIME autoheader && \\
    $CI_TIME automake --add-missing --copy && \\
    $CI_TIME autoconf || \\
    $CI_TIME autoreconf -fiv
fi
.   endif
.   if count(my.use.add_config_opts) > 0
( # Custom additional options for $(my.use.project)
.           for my.use.add_config_opts as add_cfgopt
  CONFIG_OPTS+=("$(add_cfgopt)")
.           endfor
  $CI_TIME ./configure "${CONFIG_OPTS[@]}"
)
.       else
$CI_TIME ./configure "${CONFIG_OPTS[@]}"
.       endif
$CI_TIME make -j4
$CI_TIME make install
.endmacro

    project.namespace ?= switches.namespace? "org.zeromq.$(project.prefix)"
    project.name_path ?= switches.name_path? "org/zeromq/$(project.prefix)"
    project.topdir = "bindings/jni"
    directory.create (topdir)

    generate_native_loader ()
    for project.class
        resolve_class (class)
        if class.okay
            generate_class_in_java (class)
            generate_class_in_c (class)
            generate_test_wrapper (class)
        endif
    endfor

    if count (project.class, okay = 1)
        generate_wrapper ()
    endif
endfunction
