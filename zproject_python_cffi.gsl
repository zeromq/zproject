#   Generate minimal Python language bindings that use CFFI.
#
#   These are not meant to be idiomatic, but to provide a minimal platform
#   of FFI function bindings on which to base idiomatic Python classes.
#
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
#
#   Copyright (c) the Contributors as noted in the AUTHORS file.
#   This file is part of zproject.
#
#   This Source Code Form is subject to the terms of the Mozilla Public
#   License, v. 2.0. If a copy of the MPL was not distributed with this
#   file, You can obtain one at http://mozilla.org/MPL/2.0/.

register_target ("python_cffi", "Python CFFI binding")

#   Target provides name space isolation for its functions
function target_python_cffi

function register_type (struct, pointer)
    if count(project->python_types.type, type.name = my.struct) = 0
        new project->python_types.type
            type.name = my.struct
            type.pointer = my.pointer
        endnew
    endif
endfunction

function resolve_container (container)
    if my.container.variadic
    elsif my.container.type = "nothing"
    elsif my.container.type = "anything" | my.container.type = "sockish"
    elsif my.container.type = "boolean"
    elsif my.container.type = "byte"
    elsif my.container.type = "integer" | my.container.type = "file_size" | my.container.type = "time"
    elsif my.container.type = "number"
    elsif my.container.type = "size"
    elsif my.container.type = "real"
    elsif my.container.type = "buffer"
    elsif my.container.type = "FILE"
    elsif my.container.type = "string" | my.container.type = "format"
    elsif my.container.callback
    else
        register_type ("$(my.container.type:c,no)_t", "$(my.container.type:c,no)_p")
    endif
endfunction

function resolve_method (method)
    my.method.python_name = "$(my.method.name:c)"
    if regexp.match ("^(is|from)$", my.method.python_name) # matches keyword
        my.method.python_name += "_"
    endif
    for my.method.argument where !argument.variadic
        resolve_container (argument)
    endfor
    for my.method.return as ret
        resolve_container (ret)
    endfor
endfunction

function resolve_class (class)
    register_type("$(class.c_name)_t", "$(class.c_name)_p")
    for my.class.callback_type as method
        resolve_method (method)
    endfor
    for my.class.constructor as method
        resolve_method (method)
    endfor
    for my.class.destructor as method
        resolve_method (method)
    endfor
    for my.class.method
        resolve_method (method)
    endfor
endfunction

function generate_cdefs (project)
    for my.project->python_types.type as t
        >typedef struct _$(t.name:c) $(t.name:c);
    endfor
    for class where defined (class.api) & class.private = "0"
        for class.callback_type
            >// $(callback_type.description:no,block)
            >$(c_callback_typedef (callback_type):)
            >
        endfor
    endfor
    for class where defined (class.api) & class.private = "0"
        >// CLASS: $(class.name)
        for class. as f
            if class(f) = "XML item" & (name(f) = 'constructor' | name(f) = 'destructor')
                >// $(f.description:no,block)
                >$(c_method_signature (f):);
                >
            endif
        endfor
        for class.actor
            >// $(actor.description:no,block)
            >$(PROJECT.PREFIX)_EXPORT void
            >   $(actor.name:c) (zsock_t *pipe, void *args);
            >
        endfor
        for class.method
            >// $(method.description:no,block)
            >$(c_method_signature (method):);
            >
        endfor
    endfor
endfunction

function generate_binding
    directory.create ("bindings/python_cffi/$(project.name:c)_cffi")
    output "bindings/python_cffi/$(project.name:c)_cffi/__init__.py"
    >$(project.GENERATED_WARNING_HEADER:)
    >try:
    >    from . import native
    >    lib = native.lib
    >    ffi = native.ffi
    >except ImportError:
    >    from . import dlopen
    >    lib = dlopen.lib
    >    ffi = dlopen.ffi
    >

    output "bindings/python_cffi/$(project.name:c)_cffi/dlopen.py"
    >$(project.GENERATED_WARNING_HEADER:)
    >from __future__ import print_function
    >import os
    >import sys
    >
    >import cffi
    >ffi = cffi.FFI()
    >
    >try:
    >    # If LD_LIBRARY_PATH or your OSs equivalent is set, this is the only way to
    >    # load the library.  If we use find_library below, we get the wrong result.
    >    if os.name == 'posix':
    >        if sys.platform == 'darwin':
    >            libpath = '$(project.libname).$(project->version.major).dylib'
    >        else:
    >            libpath = '$(project.libname).so.$(project->version.major)'
    >    elif os.name == 'nt':
    >        libpath = '$(project.libname).dll'
    >    lib = ffi.dlopen(libpath)
    >except OSError:
    >    libpath = find_library("$(project.name)")
    >    if not libpath:
    >        raise ImportError("Unable to find $(project.libname)")
    >    lib = ffi.dlopen(libpath)
    >
    >from $(project.name:c)_cffi.cdefs import $(project.name:c)_cdefs
    >
    >for cdef in $(project.name:c)_cdefs:
    >   ffi.cdef (cdef)

    output "bindings/python_cffi/$(project.name:c)_cffi/build.py"
    >$(project.GENERATED_WARNING_HEADER:)
    >
    >from __future__ import print_function
    >import os
    >import re
    >import sys
    >
    >import subprocess
    >def pkgconfig_installed ():
    >   try:
    >        subprocess.check_output (["pkg-config", "--version"])
    >        return True
    >   except subprocess.CalledProcessError:
    >        return False
    >
    >def pkgconfig_kwargs (libs):
    >    """If pkg-config is available, then return kwargs for set_source based on pkg-config output
    >    
    >    It setup include_dirs, library_dirs, libraries and define_macros
    >    """
    >
    >    # make API great again!
    >    if isinstance (libs, (str, bytes)):
    >        libs = (libs, )
    >    
    >    # drop starting -I -L -l from cflags
    >    def dropILl (string):
    >        def _dropILl (string):
    >            if string.startswith (b"-I") or string.startswith (b"-L") or string.startswith (b"-l"):
    >                return string [2:]
    >        return [_dropILl (x) for x in string.split ()]
    >
    >    # convert -Dfoo=bar to list of tuples [("foo", "bar")] expected by cffi
    >    def macros (string):
    >        def _macros (string):
    >            return tuple (string [2:].split (b'=', 2))
    >        return [_macros (x) for x in string.split () if x.startswith (b"-D")]
    >
    >    # pkg-config call
    >    def pc (libname, *args):
    >        a = ["pkg-config", "--print-errors"]
    >        a.extend (args)
    >        a.append (libname)
    >        return subprocess.check_output (a)
    >
    >    # return kwargs for given libname
    >    def kwargs (libname):
    >        return {
    >                "include_dirs" : dropILl (pc (libname, "--cflags-only-I")),
    >                "library_dirs" : dropILl (pc (libname, "--libs-only-L")),
    >                "libraries" : dropILl (pc (libname, "--libs-only-l")),
    >                "define_macros" : macros (pc (libname, "--cflags")),
    >                }
    >
    >    # merge all arguments together
    >    ret = {}
    >    for libname in libs:
    >        foo = kwargs (libname)
    >        for key, value in foo.items ():
    >            if not key in ret:
    >                ret [key] = value
    >            else:
    >                ret [key].extend (value)
    >
    >    # Python3 and strict unicode
    >    for key, value in ret.items ():
    >        if isinstance (value, bytes):
    >            ret [key] = value.decode ("utf-8")
    >        elif isinstance (value, list):
    >            if len (value) == 0:
    >                continue
    >            if isinstance (value[0], tuple):
    >                ret [key] = [(v[0].decode ("utf-8"), v[1].decode ("utf-8")) for v in value]
    >            else:
    >                ret [key] = [v.decode ("utf-8") for v in value]
    >
    >    return ret
    >
    >if not pkgconfig_installed ():
    >    print ("ERROR: build without pkg-config not supported", file=sys.stderr)
    >    sys.exit (1)
    >
    >kwargs = pkgconfig_kwargs ([
    for project.use where (use.pkgconfig ?<> "")
    >    "$(use.pkgconfig)",
    endfor
    >    "$(project.libname)"
    >])
    >import cffi
    ># can't import does not work, read and exec manually
    >with open (os.path.join (
    >    os.path.dirname (__file__),
    >    "cdefs.py"), 'r') as fp:
    >    cdefs_py = fp.read()
    >gl = {}
    >exec (cdefs_py, gl)
    >$(project.name:c)_cdefs = gl ["$(project.name:c)_cdefs"]
    >
    >ffibuilder = cffi.FFI ()
    >ffibuilder.set_source ("$(project.name:c)_cffi.native", "#include <$(project.header)>", **kwargs)
    >
    ># Custom setup for $(project.name)
    >for item in $(project.name:c)_cdefs:
    >    ffibuilder.cdef(item)
    >
    >ffidestructorbuilder = cffi.FFI ()
    >ffidestructorbuilder.cdef('''
    for class where defined (class.api) & class.private = "0" & count (class.destructor) > 0
    >void
    >   $(class.name:c)_destroy_py (void *self);
    >
    endfor
    >''')
    >
    >ffidestructorbuilder.set_source ("$(project.name:c)_cffi.destructors", '''
    >#include <$(project.header)>
    for class where defined (class.api) & class.private = "0" & count (class.destructor) > 0
    >void
    >$(class.name:c)_destroy_py (void *self)
    >{
    >   $(class.name:c)_destroy (($(class.name:c)_t **) &self);
    >}
    >
    endfor
    >''', **kwargs)
    >
    >if __name__ == "__main__":
    >    ffibuilder.compile (verbose=True)
    >    ffidestructorbuilder.compile (verbose=True)

    output "bindings/python_cffi/$(project.name:c)_cffi/_cdefs.inc"
    >$(project.GENERATED_WARNING_HEADER:)
    ># This file is intended to be included while generating cffi binding for top level library
    >
    >$(project.name:c)_cdefs = list ()
    ># Custom setup for $(project.name)
    >$(file.slurp('src/python_cffi.inc')?'')
    >$(project.name:c)_cdefs.append ('''
    generate_cdefs (project)
    >''')

    output "bindings/python_cffi/$(project.name:c)_cffi/cdefs.py"
    >$(project.GENERATED_WARNING_HEADER:)
    >import re
    >$(project.name:c)_cdefs = list ()
    ># Custom setup for $(project.name)
    >$(file.slurp('src/python_cffi.inc')?'')
    >
    >#Import definitions from dependent projects
    for project.use
        if file.exists ('../$(use.project:c)/bindings/python_cffi/$(use.project:c)_cffi/_cdefs.inc')
            >$(file.slurp('../$(use.project:c)/bindings/python_cffi/$(use.project:c)_cffi/_cdefs.inc'))
            >$(project.name:c)_cdefs.extend ($(use.project)_cdefs)
        endif
    endfor
    >
    >$(project.name:c)_cdefs.append ('''
    generate_cdefs (project)
    >''')
    >for i, item in enumerate ($(project.name:c)_cdefs):
    >    $(project.name:c)_cdefs [i] = re.sub(r';[^;]*\\bva_list\\b[^;]*;', ';', item, flags=re.S) # we don't support anything with a va_list arg
    >

    output "bindings/python_cffi/README.md"
    >$(project.GENERATED_WARNING_HEADER:)
    >#$(project.name) cffi bindings
    >
    >This package contains low level python bindings for $(project.name) based on cffi library.
    >Module is compatible with 
    > * The “in-line”, “ABI mode”, which simply **dlopen** main library and parse C declaration on runtime
    > * The “out-of-line”, “API mode”, which build C **native** Python extension
    >
    >#Build the native extension
    >
    >    python setup.py build
    >
    >Note you need to have setuptools and cffi packages installed. As well as a checkout of all dependencies
    >at the same level as this project, because all dependant defs.py will be included in project cdefs.py.
    >
    >#Using more cffi modules together
    >While zproject and CLASS encourages you to split your dependencies to smaller libraries, this does
    >not work well for cffi. zproject generated backends have own private cffi instance, which can't
    >be easily combined with others in one function call.
    >
    >See ML thread about topic https://groups.google.com/forum/#!topic/python-cffi/JtAKU-g9Exg
    >
    >The solution is to include all the definitions of dependant modules, so we will have an access
    >to underlying functions directly from top level module. It is a sort of static linking, but
    >the only way to ensure the cffi bindings will work accross multiple C libraries. And this is the
    >reason you need to have a checkout at the same level as the project.
    >
    >The advantage is there are no python dependencies between modules.
endfunction

    if count (class, defined (class.api) & class.private = "0")
        # Container for UDTs used by this module
        new python_types
        endnew
        for class where defined (class.api) & class.private = "0"
            resolve_class (class)
        endfor
        generate_binding ()

        output "bindings/python_cffi/setup.py"
        >$(project.GENERATED_WARNING_HEADER:)
        >from setuptools import setup
        >
        >setup(
        >    name = "$(project.name:c)_cffi",
        >    version = "$(project->version.major).$(project->version.minor).$(project->version.patch)",
        >    license = "$(project.license)",
        >    description = """Python cffi bindings of: $(project.description)""",
        >    packages = ["$(project.name:c)_cffi", ],
        >    setup_requires=["cffi"],
        >    cffi_modules=[
        >           "$(project.name:c)_cffi/build.py:ffibuilder",
        >           "$(project.name:c)_cffi/build.py:ffidestructorbuilder"
        >    ],
        >    install_requires=["cffi"],
        >)
        >$(project.GENERATED_WARNING_HEADER:)
    endif


endfunction
